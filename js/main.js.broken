import { CONSTANTS, HELPERS, BIRD_SETTINGS, createMaterials, createGeometries } from './config.js';
import { buildTerrain as importedBuildTerrain, terrainOffsetZ, fitGroundInView } from './terrain.js';
import { initUI, setupUI, UIState, getUIValues, elements } from './ui.js';
import { getConductorCurve } from '../utils/catenary.js';

// Make THREE available to our ES module by accessing it from window
const THREE = window.THREE;

document.addEventListener('DOMContentLoaded', () => {
  // Use imported constants
  const { CLEARANCE, SAMPLES, DRAG_SENS, MINH, MAXH, SIZE, SEG, BASE_H, R } = CONSTANTS;
  const { SNAP } = HELPERS;  // Initialize UI elements early (without event handlers)
  initUI();

  // We already have elements imported at the top of the file via the import statement
  // Simply use the named export 'elements' from the ui.js module

  /* ------- three basics ------- */
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(40, 40, 40);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
  const sun = new THREE.DirectionalLight(0xffffff, 0.6);
  sun.position.set(10, 40, 20);
  scene.add(sun);
  /* ------- materials ------- */
  // Get geometries from config
  const { pole: poleGeo, crossArm: crossArmGeo } = createGeometries();
  
  // Get materials from config
  const materials = createMaterials();
  const mPole = materials.pole;
  const mCrossArm = materials.crossArm;
  const mPoleHL = materials.poleHighlight;
  const mGood = materials.goodSpan;
  const mBad = materials.badSpan;
  const mGhost = materials.ghost;
  const mTreeHL = materials.treeHighlight;
  const mGrid = materials.grid;
  const mBird = materials.bird;
    // Last pole indicator material (semitransparent with glow effect)
  const mLastPoleIndicator = new THREE.LineBasicMaterial({ 
    color: 0x3498db, 
    transparent: true, 
    opacity: 0.7,
    linewidth: 2
  });

  /* ------- data stores ------- */  
  const poles = []; // {x,z,h,base,obj}
  const poleHeightLabels = []; // Array to store label objects for pole heights
  const sagCalculationObjects = []; // Array to store sag visualization objects
  const trees = new THREE.Group();
  scene.add(trees);
  const treeData = []; // {x,z,yTop,ref}
  // terrainOffsetZ is imported from terrain.js
  const ray = new THREE.Raycaster();
  const mouse = new THREE.Vector2();  
  
  const birds = [];
  let hoverPt = null, hoverPole = null, hoverTree = null;
  let ghost = new THREE.Mesh(poleGeo, mGhost);
  ghost.visible = false;
  scene.add(ghost);
    // Create terrain-conforming lines for the last pole indicator (double circle for better visibility)
  let lastPoleIndicator = new THREE.Line(new THREE.BufferGeometry(), mLastPoleIndicator);
  lastPoleIndicator.visible = false;
  scene.add(lastPoleIndicator);
  
  // Create a second, inner indicator circle
  const mLastPoleInnerIndicator = new THREE.LineBasicMaterial({ 
    color: 0x73c2fb, 
    transparent: true, 
    opacity: 0.9,
    linewidth: 1
  });
  let lastPoleInnerIndicator = new THREE.Line(new THREE.BufferGeometry(), mLastPoleInnerIndicator);
  lastPoleInnerIndicator.visible = false;
  scene.add(lastPoleInnerIndicator);
  
  let drag = null, startY = 0, startH = 0, clickStart = null;
  let dragStartPos = null, dragStartHeight = null, dragMode = null;

  const urlParams = new URLSearchParams(window.location.search);

  // Parse pole parameters from URL and normalize if needed
  const poleDistances = urlParams.get('poles-distances')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
  const poleHeights = urlParams.get('poles-heights')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
  const poleElevations = urlParams.get('poles-elevations')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
  const clearanceThresholdParam = urlParams.get('clearanceThreshold');

  const customPoles = [];
  let useElevations = [];

  // Set clearance threshold from URL parameter if provided
  if (clearanceThresholdParam && !isNaN(Number(clearanceThresholdParam))) {
    UIState.clearanceThreshold = Number(clearanceThresholdParam);
    if (elements.clearanceThreshold) {
      elements.clearanceThreshold.value = UIState.clearanceThreshold;
      elements.clearanceLabel.textContent = UIState.clearanceThreshold;
    }
  }

  // Set grid visibility from URL parameter if provided
  const showGridParam = urlParams.get('showGrid');
  if (showGridParam === 'false') {
    UIState.showGrid = false;
    if (elements.showGridCheck) {
      elements.showGridCheck.checked = false;
    }
  }

  // Set tension from URL parameter if provided
  const tensionParam = urlParams.get('tension');
  if (tensionParam && !isNaN(Number(tensionParam))) {
    UIState.currentTension = Number(tensionParam);
    if (elements.tensionSlider) {
      elements.tensionSlider.value = UIState.currentTension;
      elements.tensionLabel.textContent = `${UIState.currentTension} lbs`;
    }
  }

  // Set display options from URL parameters
  const showPoleHeightLabelsParam = urlParams.get('showPoleHeightLabels');
  if (showPoleHeightLabelsParam === 'true') {
    UIState.showPoleHeightLabels = true;
    if (elements.showPoleHeightLabels) {
      elements.showPoleHeightLabels.checked = true;
    }
  }

  const showSagCalculationsParam = urlParams.get('showSagCalculations');
  if (showSagCalculationsParam === 'true') {
    UIState.showSagCalculations = true;
    if (elements.showSagCalculations) {
      elements.showSagCalculations.checked = true;
    }
  }

  const showClearanceBuffersParam = urlParams.get('showClearanceBuffers');
  if (showClearanceBuffersParam === 'true') {
    UIState.showClearanceBuffers = true;
    if (elements.showClearanceBuffers) {
      elements.showClearanceBuffers.checked = true;
    }
  }

  if (poleDistances.length && poleHeights.length) {
    while (poleHeights.length < poleDistances.length) poleHeights.push(10);
    useElevations = poleElevations;
    while (useElevations.length < poleDistances.length) useElevations.push(0);
    
    for (let i = 0; i < poleDistances.length; i++) {
      customPoles.push({
        x: 0, 
        z: poleDistances[i], 
        h: poleHeights[i], 
        elev: useElevations[i]
      });
    }
  }

  // Custom ground function for sloped surface through pole elevations
  let customGround = null;
  if (customPoles.length > 0) {
    customGround = (x, z) => {
      const localZ = z - terrainOffsetZ;
      if (localZ <= customPoles[0].z) return customPoles[0].elev;
      if (localZ >= customPoles[customPoles.length - 1].z) return customPoles[customPoles.length - 1].elev;
      for (let i = 1; i < customPoles.length; i++) {
        if (localZ <= customPoles[i].z) {
          const t = (localZ - customPoles[i - 1].z) / (customPoles[i].z - customPoles[i - 1].z);
          return customPoles[i - 1].elev * (1 - t) + customPoles[i].elev * t;
        }
      }
      return 0;
    };
  }
  // Define the base height calculation function
  function calculateTerrainHeight(x, z) {
    return elements.terrainSelect?.value === 'flat' ? 0 : Math.sin(x*0.09)*5 + Math.cos(z*0.11)*3 + Math.sin((x+z)*0.04)*2;
  }

  // Height at specific location function
  function hAt(x, z) {
    if (customGround) {
      return customGround(x, z);
    }
    return calculateTerrainHeight(x, z);
  }

  function addGridLines(scene, terrain) {
    // Clean up existing grid objects and their DOM label elements
    clearGridElements();

    const gridGroup = new THREE.Group();
    gridGroup.userData.grid = true;
    gridGroup.userData.labels = [];

    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
    
    // Get terrain dimensions and position
    let terrainWidth = 100;
    let terrainDepth = 100;
    let terrainPosition = { x: 0, z: 0 };
    
    if (terrain) {
      terrainWidth = terrain.geometry.parameters.width;
      terrainDepth = terrain.geometry.parameters.height;
      terrainPosition.z = terrain.position.z;
    }
    
    // Calculate grid bounds to match terrain
    const startX = -terrainWidth / 2;
    const endX = terrainWidth / 2;
    const startZ = -terrainDepth / 2 + terrainPosition.z;
    const endZ = terrainDepth / 2 + terrainPosition.z;

    // Create grid lines at 10-foot intervals (X direction)
    for (let i = Math.ceil(startX / 10) * 10; i <= Math.floor(endX / 10) * 10; i += 10) {
      const points = [];
      
      // Sample points along Z-axis to follow terrain
      for (let z = startZ; z <= endZ; z += 1) {
        const y = hAt(i, z) + 0.05; // Slight offset to avoid z-fighting
        points.push(new THREE.Vector3(i, y, z));
      }
      
      const geometryX = new THREE.BufferGeometry().setFromPoints(points);
      const lineX = new THREE.Line(geometryX, gridMaterial);
      gridGroup.add(lineX);

      if (i !== 0) {
        const labelX = document.createElement('div');
        labelX.className = 'grid-label';
        labelX.textContent = `${i}`;
        labelX.style.position = 'absolute';
        labelX.style.color = 'black';
        labelX.style.backgroundColor = 'rgba(255,255,255,0.5)';
        labelX.style.padding = '2px 4px';
        labelX.style.borderRadius = '2px';
        labelX.style.fontSize = '10px';
        labelX.style.userSelect = 'none';
        labelX.style.pointerEvents = 'none';
        document.body.appendChild(labelX);

        gridGroup.userData.labels.push({
          element: labelX,
          position: new THREE.Vector3(i, hAt(i, startZ) + 0.1, startZ),
          axis: 'x'
        });
      }
    }

    // Create grid lines at 10-foot intervals (Z direction)
    for (let i = Math.ceil(startZ / 10) * 10; i <= Math.floor(endZ / 10) * 10; i += 10) {
      const points = [];
      
      // Sample points along X-axis to follow terrain
      for (let x = startX; x <= endX; x += 1) {
        const y = hAt(x, i) + 0.05; // Slight offset to avoid z-fighting
        points.push(new THREE.Vector3(x, y, i));
      }
      
      const geometryZ = new THREE.BufferGeometry().setFromPoints(points);
      const lineZ = new THREE.Line(geometryZ, gridMaterial);
      gridGroup.add(lineZ);

      if (i !== 0) {
        const labelZ = document.createElement('div');
        labelZ.className = 'grid-label';
        labelZ.textContent = `${i}`;
        labelZ.style.position = 'absolute';
        labelZ.style.color = 'black';
        labelZ.style.backgroundColor = 'rgba(255,255,255,0.5)';
        labelZ.style.padding = '2px 4px';
        labelZ.style.borderRadius = '2px';
        labelZ.style.fontSize = '10px';
        labelZ.style.userSelect = 'none';
        labelZ.style.pointerEvents = 'none';
        document.body.appendChild(labelZ);

        gridGroup.userData.labels.push({
          element: labelZ,
          position: new THREE.Vector3(startX, hAt(startX, i) + 0.1, i),
          axis: 'z'
        });
      }
    }

    scene.add(gridGroup);
  }

  function toggleGridVisibility(visible) {
    scene.children.filter(o => o.userData.grid).forEach(g => {
      g.visible = visible;
      
      if (g.userData.labels) {
        g.userData.labels.forEach(label => {
          label.element.style.display = visible ? 'block' : 'none';
        });
      }
    });
  }

    // The buildTerrain function has been moved to terrain.js and is imported as importedBuildTerrain
  // fitGroundInView is imported from terrain.js

  function addDefaultTrees(scene, hAt) {
    const trunkG = new THREE.CylinderGeometry(0.15, 0.15, 1, 6);
    const folG = new THREE.ConeGeometry(0.75, 2, 8);
    const trunkM = new THREE.MeshStandardMaterial({color: 0x8b5a2b});
    const folM = new THREE.MeshStandardMaterial({color: 0x2e8b57});
    const cluster = 20, radius = 6;
    for(let cx = -SIZE/2; cx <= SIZE/2; cx += cluster) {
      for(let cz = -SIZE/2; cz <= SIZE/2; cz += cluster) { 
        if(Math.random() < 0.35) {
          const n = THREE.MathUtils.randInt(6, 15);
          for(let i = 0; i < n; i++) {
            const ang = Math.random() * Math.PI * 2, r = Math.random() * radius;
            const x = cx + Math.cos(ang) * r, z = cz + Math.sin(ang) * r, y = hAt(x, z);
            const s = THREE.MathUtils.randFloat(0.8, 1.6);
            const trunk = new THREE.Mesh(trunkG, trunkM);
            trunk.scale.y = s;
            trunk.position.set(x, y + s * 0.5, z);
            const fol = new THREE.Mesh(folG, folM);
            fol.scale.setScalar(s);
            fol.position.set(x, y + s * 1.5, z);
            const t = new THREE.Group();
            t.add(trunk);
            t.add(fol);
            t.userData.tree = true;
            trees.add(t);
            treeData.push({x, z, yTop: y + s * 1.5, ref: t});
          }
        }
      }
    }
  }

  function clearSceneElements() {
    scene.children.filter(o => o.userData.environmentElement).forEach(obj => {
      scene.remove(obj);
      if (obj.traverse) {
        obj.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
      } else {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach(m => m.dispose());
          } else {
            obj.material.dispose();
          }
        }
      }
    });
  }

  function clearSettingElements() {
    scene.children.filter(o => o.userData.settingElement).forEach(obj => {
      scene.remove(obj);
      if (obj.traverse) {
        obj.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
      } else {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach(m => m.dispose());
          } else {
            obj.material.dispose();
          }
        }
      }
    });
  }







    const waterMaterial = new THREE.MeshStandardMaterial({
      color: 0x1e90ff,
      transparent: true,
      opacity: 0.8,
      metalness: 0.9,
      roughness: 0.1,
      envMapIntensity: 1.5
    });

    const waterGeometry = new THREE.PlaneGeometry(waterWidth, waterDepth, 32, 24);
    const water = new THREE.Mesh(waterGeometry, waterMaterial);
    water.rotation.x = -Math.PI / 2;
    water.position.set(-terrainWidth / 2 - waterWidth / 2, 0.1, terrainPos);
    water.userData.environmentElement = true;
    water.userData.isWater = true;
    const originalPositions = [];
    const posAttr = waterGeometry.attributes.position;
    for (let i = 0; i < posAttr.count; i++) {
      originalPositions.push({
        x: posAttr.getX(i),
        y: posAttr.getY(i),
        z: posAttr.getZ(i)
      });
    }
    water.userData.waveInfo = {
      time: 0,
      originalPositions
    };
    scene.add(water);

    const foamMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
    const foamGeometry = new THREE.PlaneGeometry(10, waterDepth, 1, 24);
    const foam = new THREE.Mesh(foamGeometry, foamMaterial);
    foam.rotation.x = -Math.PI / 2;
    foam.position.set(-terrainWidth / 2 - 5, 0.12, terrainPos);
    foam.userData.environmentElement = true;
    foam.userData.isWaterFoam = true;
    scene.add(foam);
  }

  function addMountainElements() {
    if (!window.terrain) return;

    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
    const terrainWidth = window.terrain.geometry.parameters.width;
    const terrainDepth = window.terrain.geometry.parameters.height;
    const terrainPos = window.terrain.position.z;

    for (let i = 0; i < 18; i++) {
      const geometry = new THREE.DodecahedronGeometry(THREE.MathUtils.randFloat(1.2, 3.5));
      const rock = new THREE.Mesh(geometry, rockMaterial.clone());
      const x = THREE.MathUtils.randFloat(-terrainWidth / 2, terrainWidth / 2);
      const z = THREE.MathUtils.randFloat(-terrainDepth / 2, terrainDepth / 2) + terrainPos;
      const y = hAt(x, z);
      rock.position.set(x, y + 1.0, z);
      rock.userData.environmentElement = true;
      scene.add(rock);
    }
  }

  function addDesertElements() {
    if (!window.terrain) return;

    const duneMaterial = new THREE.MeshStandardMaterial({ color: 0xd2b48c, roughness: 0.5 });
    const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x2e8b57 });
    const terrainWidth = window.terrain.geometry.parameters.width;
    const terrainDepth = window.terrain.geometry.parameters.height;
    const terrainPos = window.terrain.position.z;

    for (let i = 0; i < 8; i++) {
      const geometry = new THREE.ConeGeometry(THREE.MathUtils.randFloat(6, 10), THREE.MathUtils.randFloat(2, 3), 16);
      geometry.rotateX(-Math.PI / 2);
      const dune = new THREE.Mesh(geometry, duneMaterial.clone());
      const x = THREE.MathUtils.randFloat(-terrainWidth / 3, terrainWidth / 3);
      const z = THREE.MathUtils.randFloat(-terrainDepth / 2, terrainDepth / 2) + terrainPos;
      const y = hAt(x, z);
      dune.position.set(x, y + 0.5, z);
      dune.userData.environmentElement = true;
      scene.add(dune);
    }

    for (let i = 0; i < 12; i++) {
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 4, 8), cactusMaterial.clone());
      const x = THREE.MathUtils.randFloat(-terrainWidth / 2, terrainWidth / 2);
      const z = THREE.MathUtils.randFloat(-terrainDepth / 2, terrainDepth / 2) + terrainPos;
      const y = hAt(x, z);
      trunk.position.set(x, y + 2, z);
      trunk.userData.environmentElement = true;
      scene.add(trunk);
    }
  }

  function addCityElements() {
    if (!window.terrain) return;

    const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.35, roughness: 0.6 });
    const terrainWidth = window.terrain.geometry.parameters.width;
    const terrainDepth = window.terrain.geometry.parameters.height;
    const terrainPos = window.terrain.position.z;

    for (let i = 0; i < 14; i++) {
      const width = THREE.MathUtils.randFloat(2.5, 6);
      const depth = THREE.MathUtils.randFloat(2.5, 6);
      const height = THREE.MathUtils.randFloat(6, 14);
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const building = new THREE.Mesh(geometry, buildingMaterial.clone());
      const x = THREE.MathUtils.randFloat(-terrainWidth / 3, terrainWidth / 3);
      const z = THREE.MathUtils.randFloat(-terrainDepth / 2, terrainDepth / 2) + terrainPos;
      const y = hAt(x, z);
      building.position.set(x, y + height / 2, z);
      building.userData.environmentElement = true;
      scene.add(building);
    }
  }

  /* ------- UI initialization ------- */
  // Set up UI with callbacks and dependencies
  setupUI(
    // Callbacks
    {
      updateGhost,
      clearSceneElements,
      resetScene,
      updateSceneElements,
      rebuild,
      toggleGridVisibility,
      createRandomScenario,
      checkClearances,
      updatePoleHeightLabels,
      updateSagCalculations,
      copyScenarioLink,
      exportScene,
      handleFileImport
    },
    // Dependencies
    {
      scene,
      trees,
      treeData,
      urlParams,
      customPoles, 
      SEG,
      hAt,
      addGridLines,
      addDefaultTrees,
      importedBuildTerrain
    }
  );
  
  // Reference UI elements directly from the elements variable we retrieved above
  const slider = elements.slider;
  const hLabel = elements.heightLabel;
  const terrainSel = elements.terrainSelect;
  const tensionSlider = elements.tensionSlider;
  const tensionLabel = elements.tensionLabel;
  const settingSel = elements.settingSelect;
  const environmentSel = elements.environmentSelect;
  const clearBtn = elements.clearButton;
  const showGridCheck = elements.showGridCheck;

  // Use the imported buildTerrain function from terrain.js
  clearSceneElements();
  trees.clear();
  treeData.length = 0;
  const terrain = importedBuildTerrain(scene, urlParams, customPoles, elements.terrainSelect, null, SEG, hAt, addGridLines, addDefaultTrees, null);
  fitGroundInView(camera, controls, terrain);
  /* ------- terrain-conforming circle creation ------- */
  function createTerrainConformingCircle(centerX, centerZ, radius, segments, scaleFactor = 1.0) {
    const points = [];
    const scaledRadius = radius * scaleFactor;
    
    // Create a circle of points that follow the terrain contour
    for (let i = 0; i <= segments; i++) {
      const angle = (i / segments) * Math.PI * 2;
      const x = centerX + Math.cos(angle) * scaledRadius;
      const z = centerZ + Math.sin(angle) * scaledRadius;
      const y = hAt(x, z) + 0.05; // Slightly above terrain to avoid z-fighting
      
      points.push(new THREE.Vector3(x, y, z));
    }
    
    // Create a geometry from these points (closes the loop)
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    return geometry;
  }

  /* ------- simple clearance line indicator ------- */
  function createSimpleClearanceLine(conductorPoint, groundPoint, clearanceValue, isViolation = false) {
    // Create a simple vertical line from conductor to ground
    const color = isViolation ? 0xff0000 : 0x00ff00;
    const opacity = isViolation ? 0.9 : 0.6;
    
    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(conductorPoint.x, conductorPoint.y, conductorPoint.z),
      new THREE.Vector3(groundPoint.x, groundPoint.y, groundPoint.z)
    ]);
    
    const lineMaterial = new THREE.LineBasicMaterial({ 
      color: color, 
      linewidth: 2,
      transparent: true,
      opacity: opacity
    });
    
    const clearanceLine = new THREE.Line(lineGeometry, lineMaterial);
    clearanceLine.userData.clearanceIndicator = true;
    scene.add(clearanceLine);
    
    // Create text label
    const labelDiv = document.createElement('div');
    labelDiv.className = 'clearance-label';
    labelDiv.textContent = `${clearanceValue.toFixed(1)}ft`;
    labelDiv.style.position = 'absolute';
    labelDiv.style.color = isViolation ? '#ff0000' : '#00ff00';
    labelDiv.style.fontWeight = 'bold';
    labelDiv.style.fontSize = '12px';
    labelDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
    labelDiv.style.padding = '2px 4px';
    labelDiv.style.borderRadius = '3px';
    labelDiv.style.border = `1px solid ${isViolation ? '#ff0000' : '#00ff00'}`;
    labelDiv.style.userSelect = 'none';
    labelDiv.style.pointerEvents = 'none';
    labelDiv.style.zIndex = '1000';
    document.body.appendChild(labelDiv);
    
    return {
      line: clearanceLine,
      label: labelDiv,
      worldPosition: new THREE.Vector3(
        conductorPoint.x, 
        (conductorPoint.y + groundPoint.y) / 2, 
        conductorPoint.z
      )
    };
  }

  /* ------- 3D clearance buffer visualization ------- */
  function createClearanceBuffer(conductorPoints, clearanceRadius, isViolation = false) {
    // Create a tube geometry following the conductor path with clearance radius
    const curve = new THREE.CatmullRomCurve3(conductorPoints);
    
    // Use different colors and opacity based on violation status
    const color = isViolation ? 0xff4444 : 0x44ff44;
    const opacity = isViolation ? 0.6 : 0.25;
    
    const tubeGeometry = new THREE.TubeGeometry(curve, conductorPoints.length, clearanceRadius, 8, false);
    const tubeMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: opacity,
      wireframe: false,
      side: THREE.DoubleSide
    });
    
    const clearanceBuffer = new THREE.Mesh(tubeGeometry, tubeMaterial);
    clearanceBuffer.userData.clearanceBuffer = true;
    return clearanceBuffer;
  }

  /* ------- span build & check ------- */
  function checkClearances() {
    // Remove existing clearance indicators
    scene.children.filter(o => o.userData.clearanceIndicator || o.userData.clearanceBuffer).forEach(indicator => {
      scene.remove(indicator);
      if (indicator.geometry) indicator.geometry.dispose();
      if (indicator.material) indicator.material.dispose();
    });
    
    // Remove existing clearance labels
    document.querySelectorAll('.clearance-label').forEach(label => label.remove());
    
    const spans = scene.children.filter(o => o.userData.span);
    let hasIssues = false;
    const threshold = UIState.clearanceThreshold;
    const clearanceIndicators = [];
    
    // Group spans by their pole pairs (since we have 3 conductors per span alignment)
    const spanGroups = new Map();
    
    spans.forEach(span => {
      if (span.userData.a && span.userData.b) {
        const key = `${span.userData.a.uuid}-${span.userData.b.uuid}`;
        if (!spanGroups.has(key)) {
          spanGroups.set(key, []);
        }
        spanGroups.get(key).push(span);
      }
    });
    
    // Check clearances for each span alignment (group of 3 conductors)
    spanGroups.forEach((spanGroup, key) => {
      let minClearance = Infinity;
      let violationPoint = null;
      let violationType = null;
      
      // Get the first span to determine pole A and B for center conductor calculation
      const firstSpan = spanGroup[0];
      const meshA = firstSpan.userData.a;
      const meshB = firstSpan.userData.b;
      
      // Find the actual pole data structures from the meshes
      const poleA = poles.find(p => p.obj === meshA);
      const poleB = poles.find(p => p.obj === meshB);
      
      // Skip this span if we can't find the pole data
      if (!poleA || !poleB) {
        console.warn('Could not find pole data for span');
        return;
      }
      
      // Calculate the center conductor position for clearance buffer
      const tensionFactor = (UIState.currentTension - 500) / (5000 - 500) * (5.0 - 0.2) + 0.2;
      
      const centerConductorPoints = getConductorCurve({
        poleA,
        poleB,
        tension: tensionFactor,
        samples: 32,
        lateralOffset: 0, // Center conductor
        terrainOffsetZ
      });
      
      // Validate that we have valid conductor points
      if (!centerConductorPoints || centerConductorPoints.length === 0) {
        console.warn('Invalid conductor points generated');
        return;
      }
      
      // Convert to THREE.Vector3 for buffer creation, filtering out any invalid points
      const centerVector3Points = centerConductorPoints
        .filter(p => p && typeof p.x === 'number' && typeof p.y === 'number' && typeof p.z === 'number')
        .map(p => new THREE.Vector3(p.x, p.y, p.z));
      
      // Skip if we don't have enough valid points
      if (centerVector3Points.length < 2) {
        console.warn('Not enough valid points for clearance buffer');
        return;
      }
      
      // Check all conductors in this span group to find the worst violation
      spanGroup.forEach(span => {
        const positions = span.geometry.attributes.position;
        
        // Check each point along the span (sample every few points for performance)
        for (let i = 0; i < positions.count; i += 3) { // Sample every 3rd point
          const x = positions.getX(i);
          const y = positions.getY(i);
          const z = positions.getZ(i);
          
          // Check clearance to ground
          const groundHeight = hAt(x, z);
          const clearanceToGround = y - groundHeight;
          
          if (clearanceToGround < threshold && clearanceToGround < minClearance) {
            minClearance = clearanceToGround;
            violationPoint = { x, y, z, groundHeight };
            violationType = 'ground';
          }
          
          // Check clearance to buildings/structures
          const buildings = scene.children.filter(o => 
            o.userData.environmentElement || o.userData.settingElement
          );
          
          for (const building of buildings) {
            if (building.geometry && building.geometry.type === 'BoxGeometry') {
              const buildingBox = new THREE.Box3().setFromObject(building);
              const point = new THREE.Vector3(x, y, z);
              const distance = buildingBox.distanceToPoint(point);
              
              // Check if line point is too close to building
              if (distance < threshold && distance > 0 && distance < minClearance) {
                minClearance = distance;
                const closestPoint = buildingBox.clampPoint(point, new THREE.Vector3());
                violationPoint = { x, y, z, closestPoint };
                violationType = 'building';
              }
            }
          }
        }
      });
      
      // Always create clearance buffer visualization for this span (if enabled)
      if (UIState.showClearanceBuffers) {
        const hasViolation = violationPoint && minClearance < threshold;
        const clearanceBuffer = createClearanceBuffer(centerVector3Points, threshold, hasViolation);
        scene.add(clearanceBuffer);
      }
      
      // If we found a violation, create simple line indicator for this span alignment
      if (violationPoint && minClearance < threshold) {
        hasIssues = true;
        
        // Find the center conductor point closest to the violation location
        let closestCenterPoint = centerConductorPoints[0];
        let minDistance = Infinity;
        
        centerConductorPoints.forEach(point => {
          const distance = Math.hypot(point.x - violationPoint.x, point.z - violationPoint.z);
          if (distance < minDistance) {
            minDistance = distance;
            closestCenterPoint = point;
          }
        });
        
        if (violationType === 'ground') {
          // Create simple line indicator for ground clearance violation
          const groundHeight = hAt(closestCenterPoint.x, closestCenterPoint.z);
          const groundPoint = { x: closestCenterPoint.x, y: groundHeight, z: closestCenterPoint.z };
          
          const indicator = createSimpleClearanceLine(closestCenterPoint, groundPoint, minClearance, true);
          clearanceIndicators.push({
            label: indicator.label,
            worldPosition: indicator.worldPosition
          });
          
        } else if (violationType === 'building') {
          // Create simple line indicator for building clearance violation
          const indicator = createSimpleClearanceLine(
            closestCenterPoint, 
            violationPoint.closestPoint, 
            minClearance, 
            true
          );
          clearanceIndicators.push({
            label: indicator.label,
            worldPosition: indicator.worldPosition
          });
        }
      }
    });
    
    // Store clearance indicators for animation loop positioning
    window.clearanceIndicators = clearanceIndicators;
    
    // Update warning display
    const warning = elements.clearanceWarning;
    if (warning) {
      warning.style.display = hasIssues ? 'block' : 'none';
    }
    
    return !hasIssues;
  }

  function drawSpan(a, b) {
    const crossarmPositions = [-1.2, 0, 1.2];
    
    crossarmPositions.forEach(offset => {
      // Convert pounds to tension factor for catenary calculation
      // Map 500-5000 lbs to approximately 0.2-5.0 factor range
      const tensionFactor = (UIState.currentTension - 500) / (5000 - 500) * (5.0 - 0.2) + 0.2;
      
      const curvePoints = getConductorCurve({
        poleA: a,
        poleB: b,
        tension: tensionFactor,
        samples: SAMPLES,
        lateralOffset: offset,
        terrainOffsetZ
      });
      
      // Convert to THREE.Vector3 for geometry
      const pts = curvePoints.map(p => new THREE.Vector3(p.x, p.y, p.z));
      
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const line = new THREE.Line(geo, mGood);
      line.userData = { span: true, a: a.obj, b: b.obj };
      scene.add(line);
    });
  }

  function rebuild() {
    const oldSpans = scene.children.filter(o => o.userData.span);
    scene.children.filter(o => o.userData.span).forEach(l => { l.geometry.dispose(); scene.remove(l); });

    const initialLoad = !window.spansInitialized;

    for (let i = 1; i < poles.length; i++) {
      drawSpan(poles[i-1], poles[i]);
    }

    if (initialLoad) {
      initBirds();
      window.spansInitialized = true;
    } else if (oldSpans.length === 0) {
      initBirds();
    }

    updateLastPoleIndicator();
    updatePoleHeightLabels();
    updateSagCalculations();
    
    // Check clearances after rebuilding spans
    checkClearances();
  }

  function addPole(x, z, h) {
    if (poles.some(p => p.x === x && p.z === z)) return;

    const base = hAt(x, z + terrainOffsetZ);
    const mesh = new THREE.Mesh(poleGeo, mPole);
    mesh.scale.y = h / BASE_H;
    mesh.position.set(x, base + h / 2, z + terrainOffsetZ);
    mesh.userData.pole = true;

    const crossArm = new THREE.Mesh(crossArmGeo, mCrossArm);
    crossArm.position.y = 5;  
    mesh.add(crossArm);
    
    scene.add(mesh);
    poles.push({ x, z, h, base, obj: mesh });
    rebuild();
    updateCrossarmOrientations();
    updateLastPoleIndicator(); // Update the last pole indicator
  }

  function removePole(obj){ 
    const i = poles.findIndex(p => p.obj === obj); 
    if(i > -1){
      scene.remove(obj); 
      poles.splice(i, 1); 
      rebuild();
      updateCrossarmOrientations();
      updateLastPoleIndicator(); // Update the last pole indicator
    }
  }

  function updateCrossarmOrientations() {
    poles.forEach((pole, index) => {
      pole.obj.children.filter(child => child.geometry.type === 'BoxGeometry')
        .forEach(child => pole.obj.remove(child));

      const prev = index > 0 ? poles[index-1] : null;
      const next = index < poles.length-1 ? poles[index+1] : null;
      const dirs = [];
      let acuteCase = false;

      if (prev && next) {
        const v1 = new THREE.Vector3(prev.x - pole.x, 0, prev.z - pole.z).normalize();
        const v2 = new THREE.Vector3(next.x - pole.x, 0, next.z - pole.z).normalize();
        const topAngle = calculateTopAngle(prev, pole, next);
        if (topAngle >= 90) {
          dirs.push(v1, v2);
        } else {
          dirs.push(v1, v2);
          acuteCase = true;
        }
      } else if (prev) {
        dirs.push(new THREE.Vector3(prev.x - pole.x, 0, prev.z - pole.z).normalize());
      } else if (next) {
        dirs.push(new THREE.Vector3(next.x - pole.x, 0, next.z - pole.z).normalize());
      }

      dirs.forEach(dir => {
        const perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize();
        const angle = -Math.atan2(perp.z, perp.x);
        const arm = new THREE.Mesh(crossArmGeo, mCrossArm);
        if (acuteCase) arm.scale.x = 1;
        arm.position.y = 5;
        arm.rotation.y = angle;
        pole.obj.add(arm);
      });
    });
  }

  /* ------- picking helpers ------- */
  function pick(evt, list){
    mouse.set((evt.clientX / window.innerWidth) * 2 - 1, -(evt.clientY / window.innerHeight) * 2 + 1);
    ray.setFromCamera(mouse, camera);
    return ray.intersectObjects(list, true)[0]?.object || null;
  }
  
  const poleMeshes = () => poles.map(p => p.obj);
  
  function setTreeHL(t, on){
    t.traverse(m => {
      if(m.isMesh)
        m.material = on ? mTreeHL : (m.geometry.type === 'CylinderGeometry' ? 
          new THREE.MeshStandardMaterial({color: 0x8b5a2b}) : 
          new THREE.MeshStandardMaterial({color: 0x2e8b57}));
    });
  }

  function updateGhost() {    ghost.visible = false;
    if (!hoverPt || hoverPole || hoverTree) return;
    if (poles.some(p => p.x === hoverPt.x && p.z === hoverPt.z)) return;

    const h = UIState.currentHeight;
    const base = hAt(hoverPt.x, hoverPt.z + terrainOffsetZ);

    ghost.scale.y = h / BASE_H;
    ghost.position.set(hoverPt.x, base + h / 2, hoverPt.z + terrainOffsetZ);
    ghost.visible = true;
  }

  window.addEventListener('contextmenu', e => {
    e.preventDefault();
    const tPick = pick(e, trees.children);
    if (tPick) {
      trees.remove(tPick);
      treeData.splice(treeData.findIndex(t => t.ref === tPick), 1);
      rebuild();
      return;
    }
    
    const pPick = pick(e, poleMeshes());
    if (pPick) {
      removePole(pPick);
    }
  });

  window.addEventListener('pointerdown', e => {
    if (e.shiftKey) return;

    const pPick = pick(e, poleMeshes());
    if (pPick) {
      drag = pPick;
      startY = e.clientY;
      let startX = e.clientX; // Needed to add declaration
      const pole = poles.find(p => p.obj === drag);
      dragStartPos = { x: pole.x, z: pole.z };
      dragStartHeight = pole.h;
      controls.enabled = false;
      
      birds.forEach(b => {
        if (b.obj && scene.children.includes(b.obj)) {
          scene.remove(b.obj);
        }
      });
      birds.length = 0;

      dragMode = e.altKey ? 'height' : 'position';
      return;
    }
    clickStart = [e.clientX, e.clientY];
  });
  window.addEventListener('pointermove', e => {
    if (drag) {
      const pole = poles.find(p => p.obj === drag);
      
      if (dragMode === 'position') {
        mouse.set((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
        ray.setFromCamera(mouse, camera);
        let hit = null;
        
        if (window.terrain) {
          const intersections = ray.intersectObject(window.terrain, true);
          hit = intersections && intersections.length > 0 ? intersections[0] : null;
        }
        
        if (hit) {
          pole.x = SNAP(hit.point.x);
          pole.z = SNAP(hit.point.z - terrainOffsetZ);
          
          const base = hAt(pole.x, pole.z + terrainOffsetZ);
          pole.base = base;
          pole.obj.position.set(pole.x, base + pole.h / 2, pole.z + terrainOffsetZ);
        }
      } else if (dragMode === 'height') {
        // Height dragging doesn't need terrain intersection - just use mouse delta
        const deltaY = startY - e.clientY;
        const newHeight = Math.max(MINH, Math.min(MAXH, dragStartHeight + deltaY * DRAG_SENS));
        pole.h = SNAP(newHeight);
        pole.obj.scale.y = pole.h / BASE_H;
        pole.obj.position.y = pole.base + pole.h / 2;
      }
      
      if (pole) {
        rebuild();
        updateCrossarmOrientations();
      }
      return;
    }

    const pPick = pick(e, poleMeshes());
    if (pPick !== hoverPole) {
      if (hoverPole) hoverPole.material = mPole;
      hoverPole = pPick;
      if (hoverPole) hoverPole.material = mPoleHL;
    }

    const tPick = pick(e, trees.children);
    if (tPick !== hoverTree) {
      if (hoverTree) setTreeHL(hoverTree, false);
      hoverTree = tPick;
      if (hoverTree) setTreeHL(hoverTree, true);
    }    mouse.set((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
    ray.setFromCamera(mouse, camera);
    let hit = null;
    
    if (window.terrain) {
      const intersections = ray.intersectObject(window.terrain, true);
      hit = intersections && intersections.length > 0 ? intersections[0] : null;
    }

    if (hit) {
      hoverPt = {
        x: SNAP(hit.point.x),
        z: SNAP(hit.point.z - terrainOffsetZ),
      };
    } else {
      hoverPt = null;
    }

    updateGhost();
  });

  window.addEventListener('pointerup', e => {
    if (drag) {
      drag = null;
      controls.enabled = true;
      updateLastPoleIndicator(); // Update indicator after drag operation completes
      return;
    }
    if (!clickStart) return;
    const [dx, dy] = [Math.abs(e.clientX - clickStart[0]), Math.abs(e.clientY - clickStart[1])];
    clickStart = null;    
    if (dx < 5 && dy < 5 && hoverPt) {
      const h = UIState.currentHeight;
      const base = hAt(hoverPt.x, hoverPt.z + terrainOffsetZ);
      addPole(hoverPt.x, hoverPt.z, h);
      updateGhost();
    }
  });
  function clearAllDOMLabels() {
    // Clear grid labels
    document.querySelectorAll('.grid-label').forEach(label => {
      if (label.parentNode) {
        label.parentNode.removeChild(label);
      }
    });

    // Clear pole height labels
    document.querySelectorAll('.pole-height-label').forEach(label => {
      if (label.parentNode) {
        label.parentNode.removeChild(label);
      }
    });

    // Clear clearance/sag calculation labels (they might not have specific classes)
    // This is a more aggressive cleanup for labels that might not be properly categorized
    document.querySelectorAll('div[style*="position: absolute"][style*="z-index"]').forEach(label => {
      if (label.parentNode === document.body && 
          (label.textContent.includes('ft') || label.style.backgroundColor.includes('rgba'))) {
        label.parentNode.removeChild(label);
      }
    });
  }

  function clearGridElements() {
    // Clean up grid objects and their DOM label elements
    scene.children.filter(o => o.userData.grid).forEach(g => {
      // Remove DOM label elements first
      if (g.userData.labels) {
        g.userData.labels.forEach(label => {
          if (label.element && label.element.parentNode) {
            label.element.parentNode.removeChild(label.element);
          }
        });
      }
      
      scene.remove(g);
      if (g.geometry) g.geometry.dispose();
    });
  }

  function resetScene() {
    clearSceneElements();
    clearSettingElements();
    clearGridElements(); // Clean up grid and its DOM labels

    // Clean up all DOM labels comprehensively
    clearAllDOMLabels();
    
    // Clean up pole height labels array
    poleHeightLabels.length = 0;

    poles.forEach(p => scene.remove(p.obj));
    poles.length = 0;
    scene.children.filter(o => o.userData.span).forEach(l => {
      l.geometry.dispose();
      scene.remove(l);
    });
    updateGhost();
    birds.length = 0;

    // Hide all indicators when resetting
    lastPoleIndicator.visible = false;
    lastPoleInnerIndicator.visible = false;
    
    // Hide clearance warning when scene is reset
    if (elements.clearanceWarning) {
      elements.clearanceWarning.style.display = 'none';
    }
  }

  function createRandomScenario() {
    const terrainChoices = ['flat', 'hills', 'hillsTrees'];
    const choice = terrainChoices[Math.floor(Math.random() * terrainChoices.length)];
    if (elements.terrainSelect) {
      elements.terrainSelect.value = choice;
      elements.terrainSelect.onchange();
    } else {
      resetScene();
    }

    let z = 0;
    for (let i = 0; i < 5; i++) {
      if (i > 0) z += THREE.MathUtils.randInt(15, 25);
      const h = THREE.MathUtils.randInt(10, 30);
      addPole(0, z, h);
    }
  }

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  /* ------- geometric calculations ------- */
  function calculateTopAngle(p1, p2, p3) {
    const angle1 = Math.atan2(p1.z - p2.z, p1.x - p2.x) * (180 / Math.PI);
    const angle2 = Math.atan2(p3.z - p2.z, p3.x - p2.x) * (180 / Math.PI);
    
    let diff = Math.abs(angle2 - angle1);
    if (diff > 180) diff = 360 - diff;
    
    return diff;
  }

  // Place custom poles on load
  if (customPoles.length > 0) {
    poles.length = 0;

    for (const pole of customPoles) {
      const mesh = new THREE.Mesh(poleGeo, mPole);
      const scaledHeight = pole.h;
      mesh.scale.y = scaledHeight / BASE_H;
      const zPos = pole.z;
      const xPos = 0; // Center poles in the strip
      const base = pole.elev;
      mesh.position.set(xPos, base + scaledHeight / 2, zPos + terrainOffsetZ);
      mesh.userData.pole = true;

      const crossArm = new THREE.Mesh(crossArmGeo, mCrossArm);
      crossArm.position.y = 5;
      mesh.add(crossArm);

      scene.add(mesh);
      poles.push({ x: xPos, z: zPos, h: scaledHeight, base, obj: mesh });
    }
    
    rebuild();
    updateCrossarmOrientations();
    updateLastPoleIndicator(); // Update the last pole indicator for custom poles
  }

  function createBird() {
    const group = new THREE.Group();
    
    // Bird body
    const bodyGeo = new THREE.ConeGeometry(0.15, 0.5, 4);
    bodyGeo.rotateX(Math.PI / 2);
    const body = new THREE.Mesh(bodyGeo, mBird);
    group.add(body);
    
    // Head
    const headGeo = new THREE.SphereGeometry(0.08, 8, 8);
    const head = new THREE.Mesh(headGeo, mBird);
    head.position.set(0.2, 0.08, 0);
    group.add(head);
    
    // Wings
    const wingGeo = new THREE.PlaneGeometry(0.3, 0.2);
    
    const leftWing = new THREE.Mesh(
      wingGeo,
      new THREE.MeshStandardMaterial({ color: 0x222222, side: THREE.DoubleSide })
    );
    leftWing.position.set(0, 0, 0.15);
    leftWing.rotation.y = Math.PI / 4;
    group.add(leftWing);
    
    const rightWing = new THREE.Mesh(
      wingGeo,
      new THREE.MeshStandardMaterial({ color: 0x222222, side: THREE.DoubleSide })
    );
    rightWing.position.set(0, 0, -0.15);
    rightWing.rotation.y = -Math.PI / 4;
    group.add(rightWing);
    
    // Bird properties
    const bird = {
      obj: group,
      perched: false,
      flying: false,
      targetPosition: null,
      span: null,
      spanPoint: null,
      spanOffset: null,
      wingDirection: 1,
      wingAngle: 0,
      lookDirection: new THREE.Vector3(1, 0, 0),
      
      update: function(delta) {
        if (this.flying) {
          this.updateFlying(delta);
        } else if (this.perched) {
          this.updatePerched(delta);
        } else {
          this.findPerch();
        }
      },
      
      updateFlying: function(delta) {
        if (!this.targetPosition) {
          this.findPerch();
          return;
        }        // Move toward target
        const moveSpeed = BIRD_SETTINGS.flySpeed * delta;
        const direction = new THREE.Vector3().subVectors(this.targetPosition, this.obj.position).normalize();
        this.obj.position.add(direction.multiplyScalar(moveSpeed));
        this.lookDirection.lerp(direction, 0.1);
        
        // Set bird orientation
        this.obj.lookAt(this.obj.position.clone().add(this.lookDirection));
        
        // Flap wings
        this.wingAngle += BIRD_SETTINGS.wingSpeed * this.wingDirection;
        if (Math.abs(this.wingAngle) >= 0.5) {
          this.wingDirection *= -1;
        }
        
        this.obj.children[2].rotation.z = this.wingAngle; // Left wing
        this.obj.children[3].rotation.z = -this.wingAngle; // Right wing
        
        // Check if we've reached the target
        if (this.obj.position.distanceTo(this.targetPosition) < 0.2) {
          if (this.span) {
            this.perched = true;
            this.flying = false;
            this.wingAngle = 0;
            this.obj.children[2].rotation.z = 0;
            this.obj.children[3].rotation.z = 0;
          } else {
            this.findPerch();
          }
        }
      },
      
      updatePerched: function() {
        // Occasionally look around or adjust position
        if (Math.random() < 0.005) {
          this.obj.rotation.y += (Math.random() - 0.5) * 0.2;
        }
        
        // If the span is removed, fly away
        if (!scene.children.includes(this.span)) {
          this.flyAway();
        }
      },
      
      findPerch: function() {
        const spans = scene.children.filter(o => o.userData.span);
        if (spans.length === 0) {
          this.flyAway();
          return;
        }
        
        // Pick a random span
        const span = spans[Math.floor(Math.random() * spans.length)];
        
        // Pick a random point along the span
        const positions = span.geometry.attributes.position;
        const pointIndex = Math.floor(Math.random() * (positions.count - 2) + 1);
          // Get the position on the span
        const point = new THREE.Vector3(
          positions.getX(pointIndex),
          positions.getY(pointIndex) + BIRD_SETTINGS.perchHeight,
          positions.getZ(pointIndex)
        );
        
        this.span = span;
        this.targetPosition = point;
        this.spanPoint = pointIndex;
        this.spanOffset = BIRD_SETTINGS.perchHeight;
        
        // If not already flying, start flying
        if (!this.flying) {
          this.flying = true;
          this.perched = false;
          
          // If bird isn't in the scene yet, position it randomly above
          if (!scene.children.includes(this.obj)) {
            const randomPos = new THREE.Vector3(
              point.x + (Math.random() - 0.5) * 20,
              point.y + 10 + Math.random() * 10,
              point.z + (Math.random() - 0.5) * 20
            );
            this.obj.position.copy(randomPos);
            scene.add(this.obj);
          }
          
          // Look toward the target
          this.lookDirection = new THREE.Vector3().subVectors(this.targetPosition, this.obj.position).normalize();
        }
      },
      
      flyAway: function() {
        this.span = null;
        this.perched = false;
        this.flying = true;
        
        // Fly up and slightly away
        const flyDirection = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          1,
          (Math.random() - 0.5) * 2
        ).normalize();
        
        this.targetPosition = new THREE.Vector3().addVectors(
          this.obj.position,
          flyDirection.multiplyScalar(15)
        );
        
        // After flying away, try to find a new perch
        setTimeout(() => {
          if (this.obj && scene.children.includes(this.obj)) {
            this.findPerch();
          }
        }, 2000 + Math.random() * 3000);
      }
    };
    
    return bird;
  }

  function initBirds() {
    birds.forEach(bird => {
      if (bird.obj && scene.children.includes(bird.obj)) {
        scene.remove(bird.obj);
      }
    });
    birds.length = 0;
      const spans = scene.children.filter(o => o.userData.span);
    if (spans.length === 0) return;
    
    for (let i = 0; i < BIRD_SETTINGS.count; i++) {
      if (Math.random() < BIRD_SETTINGS.spawnChance) {
        const bird = createBird();
        birds.push(bird);
        
        setTimeout(() => {
          bird.findPerch();
        }, i * 500);
      }
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    
    // Update grid labels position if they exist
    scene.children.filter(o => o.userData.grid && o.userData.labels).forEach(grid => {
      if (grid.userData.labels && grid.visible) {
        grid.userData.labels.forEach(label => {
          const screenPosition = label.position.clone();
          screenPosition.project(camera);
          
          const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;
          
          if (screenPosition.z < 1) {
            label.element.style.display = 'block';
            label.element.style.transform = `translate(-50%, -50%)`;
            label.element.style.left = `${x}px`;
            label.element.style.top = `${y}px`;
          } else {
            label.element.style.display = 'none';
          }
        });
      } else if (grid.userData.labels) {
        grid.userData.labels.forEach(label => {
          label.element.style.display = 'none';
        });
      }
    });

    // Update pole height labels position if they exist
    if (UIState.showPoleHeightLabels && poleHeightLabels.length > 0) {
      poleHeightLabels.forEach(label => {
        const screenPosition = label.position.clone();
        screenPosition.project(camera);
        
        const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;
        
        if (screenPosition.z < 1) {
          label.element.style.display = 'block';
          label.element.style.transform = `translate(-50%, -50%)`;
          label.element.style.left = `${x}px`;
          label.element.style.top = `${y}px`;
        } else {
          label.element.style.display = 'none';
        }
      });
    } else if (poleHeightLabels.length > 0) {
      poleHeightLabels.forEach(label => {
        label.element.style.display = 'none';
      });
    }

    // Update sag calculation labels position if they exist
    if (UIState.showSagCalculations && sagCalculationObjects.length > 0) {
      sagCalculationObjects.forEach(sagObj => {
        const screenPosition = sagObj.labelPosition.clone();
        screenPosition.project(camera);
        
        const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;
        
        if (screenPosition.z < 1) {
          sagObj.label.style.display = 'block';
          sagObj.label.style.transform = `translate(-50%, -50%)`;
          sagObj.label.style.left = `${x}px`;
          sagObj.label.style.top = `${y}px`;
        } else {
          sagObj.label.style.display = 'none';
        }
      });
    } else if (sagCalculationObjects.length > 0) {
      sagCalculationObjects.forEach(sagObj => {
        sagObj.label.style.display = 'none';
      });
    }
    
    // Update last pole indicator
    if (lastPoleIndicator.visible) {
      updateLastPoleIndicator();
    }
    
    // Update clearance indicator label positions
    if (window.clearanceIndicators) {
      window.clearanceIndicators.forEach(indicator => {
        const screenPosition = indicator.worldPosition.clone();
        screenPosition.project(camera);
        
        const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;
        
        if (screenPosition.z < 1) {
          indicator.label.style.display = 'block';
          indicator.label.style.left = `${x}px`;
          indicator.label.style.top = `${y}px`;
          indicator.label.style.transform = 'translate(-50%, -50%)';
        } else {
          indicator.label.style.display = 'none';
        }
      });
    }
    
    // Update birds
    const delta = 0.016; // Approximate frame time
    birds.forEach(bird => bird.update(delta));
    
    // Update coastal water waves if present
    const waterMesh = scene.children.find(o => o.userData.isWater);
    if (waterMesh && waterMesh.userData.waveInfo) {
      const waveInfo = waterMesh.userData.waveInfo;
      waveInfo.time += delta * 0.5;
      
      // Animate water vertices to create gentle waves
      const positions = waterMesh.geometry.attributes.position;
      const originalPos = waveInfo.originalPositions;
      
      for (let i = 0; i < positions.count; i++) {
        const orig = originalPos[i];
        
        // Get position relative to shoreline for wave intensity
        const distFromShore = orig.x + 40; // Assuming shoreline is at x = -40
        const waveMultiplier = Math.min(1, Math.max(0, distFromShore / 60)); 
        
        // Create gentle wave motion
        const wavePhase = waveInfo.time + orig.z * 0.05;
        const waveHeight = 0.2 * waveMultiplier * Math.sin(wavePhase);
        
        // Additional smaller ripples
        const ripplePhase1 = waveInfo.time * 1.2 + orig.x * 0.1;
        const ripplePhase2 = waveInfo.time * 0.8 - orig.z * 0.08;
        const rippleHeight = 0.05 * Math.sin(ripplePhase1) * Math.sin(ripplePhase2);
        
        positions.setY(i, orig.y + waveHeight + rippleHeight);
      }
      
      positions.needsUpdate = true;
      
      // Animate foam at shoreline
      const foam = scene.children.find(o => o.userData.isWaterFoam);
      if (foam) {
        // Make foam move slightly up and down with waves
        const foamHeight = 0.12 + 0.05 * Math.sin(waveInfo.time * 1.2);
        foam.position.y = foamHeight;
        
        // Vary foam opacity with wave motion
        const foamOpacity = 0.6 + 0.2 * Math.sin(waveInfo.time);
        foam.material.opacity = foamOpacity;
      }
    }
    
    renderer.render(scene, camera);
  }
  animate();

  function updateSceneElements() {
    clearSettingElements();
    updatePoleAppearance();
    addRandomBuildings();
    addRoads();
  }

  function updatePoleAppearance() {
    // Default to distribution equipment colors
    let poleColor = 0x8b5a2b; // Brown pole color
    let crossArmColor = 0x4d4d4d; // Dark gray crossarm color
    
    poles.forEach(pole => {
      pole.obj.material.color.setHex(poleColor);
      
      pole.obj.children.forEach(child => {
        if (child.geometry.type === 'BoxGeometry') {
          child.material.color.setHex(crossArmColor);
        }
      });
    });
    
    mPole.color.setHex(poleColor);
    mCrossArm.color.setHex(crossArmColor);
  }

  function addRandomBuildings() {
    if (!window.terrain) return;

    const terrainWidth = window.terrain.geometry.parameters.width;
    const terrainDepth = window.terrain.geometry.parameters.height;
    const terrainPos = window.terrain.position.z;    if (elements.settingSelect.value === 'residential') {
      const buildingSize = 3;
      const buildingHeight = 5;
      const rowSpacing = 10;
      const colSpacing = 10;
      const maxBuildings = 20;

      const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x8b0000 });

      let buildingCount = 0;
      for (let row = 0; row < terrainDepth / rowSpacing && buildingCount < maxBuildings; row++) {
        for (let col = 0; col < terrainWidth / colSpacing && buildingCount < maxBuildings; col++) {
          const x = -terrainWidth / 2 + col * colSpacing + buildingSize / 2;
          const z = -terrainDepth / 2 + row * rowSpacing + buildingSize / 2 + terrainPos;
          const y = hAt(x, z) + buildingHeight / 2;

          const buildingGeometry = new THREE.BoxGeometry(buildingSize, buildingHeight, buildingSize);
          const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
          building.position.set(x, y, z);
          building.userData.environmentElement = true;
          building.userData.settingElement = true;

          scene.add(building);
          buildingCount++;
        }
      }
    }
  }

  function addRoads() {
    if (!window.terrain) return;

    const terrainWidth = window.terrain.geometry.parameters.width;
    const terrainDepth = window.terrain.geometry.parameters.height;
    const terrainPos = window.terrain.position.z;

    const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

    for (let row = 0; row <= Math.ceil(20 / Math.floor(terrainWidth / 10)); row++) {
      const roadGeometry = new THREE.PlaneGeometry(terrainWidth, 2, 1, Math.floor(terrainWidth / 2));
      const road = new THREE.Mesh(roadGeometry, roadMaterial);

      const positions = road.geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i) - terrainDepth / 2 + row * 10 + terrainPos;
        positions.setY(i, hAt(x, z));
      }

      road.rotation.x = -Math.PI / 2;
      road.geometry.attributes.position.needsUpdate = true;
      road.geometry.computeVertexNormals();
      road.userData.environmentElement = true;
      road.userData.settingElement = true;
      scene.add(road);
    }

    for (let col = 0; col <= Math.floor(terrainWidth / 10); col++) {
      const roadGeometry = new THREE.PlaneGeometry(2, terrainDepth, 1, Math.floor(terrainDepth / 2));
      const road = new THREE.Mesh(roadGeometry, roadMaterial);

      const positions = road.geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i) - terrainWidth / 2 + col * 10;
        const z = positions.getZ(i) + terrainPos;
        positions.setY(i, hAt(x, z));
      }

      road.rotation.x = -Math.PI / 2;
      road.geometry.attributes.position.needsUpdate = true;
      road.geometry.computeVertexNormals();
      road.userData.environmentElement = true;
      road.userData.settingElement = true;
      scene.add(road);
    }
  }  function updateLastPoleIndicator() {
    if (poles.length === 0) {
      lastPoleIndicator.visible = false;
      lastPoleInnerIndicator.visible = false;
      return;
    }
    
    // Get the last pole in the array
    const lastPole = poles[poles.length - 1];
    
    // Calculate pulse factors for scale and opacity
    const currentTime = Date.now() * 0.003;
    const outerPulse = Math.sin(currentTime);
    const innerPulse = Math.sin(currentTime + Math.PI); // Opposite phase
    
    // Scale factors (subtle 10% diameter change)
    const outerScaleFactor = 1 + 0.1 * Math.abs(outerPulse);
    const innerScaleFactor = 1 + 0.1 * Math.abs(innerPulse);
    
    // Create terrain-conforming geometry for the outer indicator with scale
    const indicatorGeometry = createTerrainConformingCircle(
      lastPole.x, 
      lastPole.z + terrainOffsetZ, 
      1.0, 
      32,
      outerScaleFactor
    );
    
    // Update the geometry of the indicators
    if (lastPoleIndicator.geometry) {
      lastPoleIndicator.geometry.dispose();
    }
    lastPoleIndicator.geometry = indicatorGeometry;
    

    // Also pulse the opacity for enhanced visibility
    const outerOpacity = 0.4 + 0.4 * Math.abs(outerPulse);
    
    lastPoleIndicator.material.opacity = outerOpacity;
    
    lastPoleIndicator.visible = true;
  }

  function updatePoleHeightLabels() {
    // Clear existing labels
    poleHeightLabels.forEach(label => {
      if (label.element && label.element.parentNode) {
        label.element.parentNode.removeChild(label.element);
      }
    });
    poleHeightLabels.length = 0;

    if (!UIState.showPoleHeightLabels) {
      return; // Labels are disabled, so we're done
    }

    // Create new labels for each pole
    poles.forEach(pole => {
      try {
        // Create label text showing height in feet
        const heightText = `${pole.h.toFixed(0)}ft`;
        
        // Create DOM element for the label
        const labelElement = document.createElement('div');
        labelElement.className = 'pole-height-label';
        labelElement.textContent = heightText;
        labelElement.style.position = 'absolute';
        labelElement.style.color = 'white';
        labelElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
        labelElement.style.padding = '2px 6px';
        labelElement.style.borderRadius = '3px';
        labelElement.style.fontSize = '11px';
        labelElement.style.fontWeight = 'bold';
        labelElement.style.userSelect = 'none';
        labelElement.style.pointerEvents = 'none';
        labelElement.style.whiteSpace = 'nowrap';
        labelElement.style.zIndex = '1000';
        document.body.appendChild(labelElement);
        
        // Store label info for positioning updates
        poleHeightLabels.push({
          element: labelElement,
          position: new THREE.Vector3(
            pole.x,
            pole.base + pole.h + 3, // 3 units above the pole top
            pole.z + terrainOffsetZ
          )
        });
      } catch (error) {
        console.warn('Error creating pole height label:', error);
      }
    });
  }

  function updateSagCalculations() {
    // Clear existing sag visualization objects
    sagCalculationObjects.forEach(obj => {
      scene.remove(obj.line);
      scene.remove(obj.sagLine);
      if (obj.line.geometry) obj.line.geometry.dispose();
      if (obj.sagLine.geometry) obj.sagLine.geometry.dispose();
      if (obj.label && obj.label.parentNode) {
        obj.label.parentNode.removeChild(obj.label);
      }
    });
    sagCalculationObjects.length = 0;

    if (!UIState.showSagCalculations || poles.length < 2) {
      return; // Sag calculations are disabled or not enough poles
    }

    // Create sag visualization for each span
    for (let i = 1; i < poles.length; i++) {
      const poleA = poles[i-1];
      const poleB = poles[i];

      try {
        // Calculate straight line between poles at crossarm height
        const crossarmHeightA = poleA.base + poleA.h;
        const crossarmHeightB = poleB.base + poleB.h;

        // Create straight line geometry
        const straightLinePoints = [
          new THREE.Vector3(poleA.x, crossarmHeightA, poleA.z + terrainOffsetZ),
          new THREE.Vector3(poleB.x, crossarmHeightB, poleB.z + terrainOffsetZ)
        ];
        const straightLineGeometry = new THREE.BufferGeometry().setFromPoints(straightLinePoints);
        const straightLineMaterial = new THREE.LineBasicMaterial({ 
          color: 0xffff00, 
          linewidth: 2,
          opacity: 0.7,
          transparent: true
        });
        const straightLine = new THREE.Line(straightLineGeometry, straightLineMaterial);

        // Get the catenary curve points to find maximum sag
        // Convert pounds to tension factor for catenary calculation
        const tensionFactor = (UIState.currentTension - 500) / (5000 - 500) * (5.0 - 0.2) + 0.2;
        
        const curvePoints = getConductorCurve({
          poleA,
          poleB,
          tension: tensionFactor,
          samples: 32,
          lateralOffset: 0, // Use center conductor
          terrainOffsetZ
        });

        // Find the point with maximum sag (should be around the middle)
        let maxSagPoint = curvePoints[0];
        let maxSagIndex = 0;
        let maxSagDistance = 0;

        curvePoints.forEach((point, index) => {
          // Calculate the straight line height at this position
          const t = index / (curvePoints.length - 1);
          const straightLineHeight = crossarmHeightA + (crossarmHeightB - crossarmHeightA) * t;
          const sagDistance = straightLineHeight - point.y;
          
          if (sagDistance > maxSagDistance) {
            maxSagDistance = sagDistance;
            maxSagPoint = point;
            maxSagIndex = index;
          }
        });

        // Create vertical sag line
        const t = maxSagIndex / (curvePoints.length - 1);
        const straightLineHeight = crossarmHeightA + (crossarmHeightB - crossarmHeightA) * t;
        
        const sagLinePoints = [
          new THREE.Vector3(maxSagPoint.x, straightLineHeight, maxSagPoint.z),
          new THREE.Vector3(maxSagPoint.x, maxSagPoint.y, maxSagPoint.z)
        ];
        const sagLineGeometry = new THREE.BufferGeometry().setFromPoints(sagLinePoints);
        const sagLineMaterial = new THREE.LineBasicMaterial({ 
          color: 0xff6b6b, 
          linewidth: 3,
          opacity: 0.9,
          transparent: true
        });
        const sagLine = new THREE.Line(sagLineGeometry, sagLineMaterial);

        // Create DOM label for sag measurement
        const sagText = `${maxSagDistance.toFixed(1)}ft sag`;
        const labelElement = document.createElement('div');
        labelElement.textContent = sagText;
        labelElement.style.position = 'absolute';
        labelElement.style.color = '#ff6b6b';
        labelElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
        labelElement.style.padding = '2px 6px';
        labelElement.style.borderRadius = '3px';
        labelElement.style.fontSize = '11px';
        labelElement.style.fontWeight = 'bold';
        labelElement.style.userSelect = 'none';
        labelElement.style.pointerEvents = 'none';
        labelElement.style.whiteSpace = 'nowrap';
        labelElement.style.zIndex = '1000';
        labelElement.style.border = '1px solid #ff6b6b';
        document.body.appendChild(labelElement);

        // Add to scene
        scene.add(straightLine);
        scene.add(sagLine);

        // Store for cleanup and label positioning
        sagCalculationObjects.push({
          line: straightLine,
          sagLine: sagLine,
          label: labelElement,
          labelPosition: new THREE.Vector3(
            maxSagPoint.x,
            maxSagPoint.y - 1, // Slightly below the sag point
            maxSagPoint.z
          )
        });

      } catch (error) {
        console.warn('Error creating sag calculation for span:', error);
      }
    }
  }

  function copyScenarioLink() {
    try {
      // Build the current scenario URL
      const params = new URLSearchParams();
      
      // Serialize poles if any exist
      if (poles.length > 0) {
        // Calculate distances from first pole
        const distances = poles.map((pole, i) => {
          if (i === 0) return 0;
          const dx = pole.x - poles[0].x;
          const dz = pole.z - poles[0].z;
          return Math.round(Math.sqrt(dx * dx + dz * dz));
        });
        params.set('poles-distances', distances.join(','));
        
        // Heights
        const heights = poles.map(pole => Math.round(pole.h));
        params.set('poles-heights', heights.join(','));
        
        // Elevations
        const elevations = poles.map(pole => Math.round(pole.base));
        params.set('poles-elevations', elevations.join(','));
      }
      
      // Add current UI state
      if (UIState.clearanceThreshold !== 15) { // Only add if not default
        params.set('clearanceThreshold', UIState.clearanceThreshold.toString());
      }
      
      if (UIState.currentTension !== 2000) { // Only add if not default
        params.set('tension', UIState.currentTension.toString());
      }
      
      // Add terrain/environment/setting if not default
      if (elements.terrainSelect && elements.terrainSelect.value !== 'flat') {
        params.set('terrain', elements.terrainSelect.value);
      }
      
      if (elements.environmentSelect && elements.environmentSelect.value !== 'rural') {
        params.set('environment', elements.environmentSelect.value);
      }
      
      if (elements.settingSelect && elements.settingSelect.value !== 'distribution') {
        params.set('setting', elements.settingSelect.value);
      }
      
      
      // Grid visibility
      if (UIState.showGrid === false) { // Only add if not default (true)
        params.set('showGrid', 'false');
      }

      // Display options
      if (UIState.showPoleHeightLabels === true) { // Only add if enabled
        params.set('showPoleHeightLabels', 'true');
      }

      if (UIState.showSagCalculations === true) { // Only add if enabled
        params.set('showSagCalculations', 'true');
      }

      if (UIState.showClearanceBuffers === true) { // Only add if enabled
        params.set('showClearanceBuffers', 'true');
      }
      
      // Build the full URL
      const baseUrl = window.location.origin + window.location.pathname;
      const fullUrl = params.toString() ? `${baseUrl}?${params.toString()}` : baseUrl;
      
      // Copy to clipboard
      navigator.clipboard.writeText(fullUrl).then(() => {
        // Show toast notification
        if (elements.copyLinkToast) {
          elements.copyLinkToast.style.display = 'block';
          setTimeout(() => {
            elements.copyLinkToast.style.display = 'none';
          }, 2000); // Hide after 2 seconds
        }
      }).catch(err => {
        console.warn('Failed to copy to clipboard:', err);
        // Fallback: show the URL in an alert
        alert('Copy this URL:\n' + fullUrl);
      });
      
    } catch (error) {
      console.error('Error generating scenario link:', error);
      alert('Error generating link. Please try again.');
    }
  }

  function exportScene() {
    try {
      // Get current terrain info
      const currentTerrain = window.terrain;
      const terrainData = {
        dimensions: {
          width: currentTerrain ? currentTerrain.geometry.parameters.width : 100,
          depth: currentTerrain ? currentTerrain.geometry.parameters.height : 100
        },
        offset: {
          x: currentTerrain ? currentTerrain.position.x : 0,
          z: currentTerrain ? currentTerrain.position.z : terrainOffsetZ
        },
        type: elements.terrainSelect?.value || 'flat',
        gridSize: {
          x: poles.length > 0 ? 20 : 100, // Based on buildTerrain logic
          y: 100
        },
        terrainOffsetZ: terrainOffsetZ // Include the actual terrain offset
      };

      // If poles exist, capture the elevation interpolation data
      const surfaceData = {
        hasCustomGround: customGround !== null,
        elevationProfile: null
      };

      if (poles.length > 0 && customGround) {
        // Sample the terrain at multiple points to capture the elevation profile
        const minZ = Math.min(...poles.map(p => p.z));
        const maxZ = Math.max(...poles.map(p => p.z));
        const sampleCount = 50; // Number of samples along Z-axis
        const elevationProfile = [];
        
        for (let i = 0; i <= sampleCount; i++) {
          const z = minZ + (maxZ - minZ) * (i / sampleCount);
          const elevation = hAt(0, z); // Sample at x=0 (center line)
          elevationProfile.push({ z, elevation });
        }
        
        surfaceData.elevationProfile = elevationProfile;
        surfaceData.bounds = { minZ, maxZ };
      }

      // Create scene data object
      const sceneData = {
        version: "1.1", // Increment version to indicate terrain data inclusion
        timestamp: new Date().toISOString(),
        poles: poles.map(pole => ({
          x: pole.x,
          z: pole.z,
          height: pole.h,
          elevation: pole.base
        })),
        terrain: terrainData,
        surface: surfaceData,
        settings: {
          tension: UIState.currentTension,
          clearanceThreshold: UIState.clearanceThreshold,
          terrain: elements.terrainSelect?.value || 'flat',
          showGrid: UIState.showGrid,
          showSagCalculations: UIState.showSagCalculations,
          showClearanceBuffers: UIState.showClearanceBuffers,
          showPoleHeightLabels: UIState.showPoleHeightLabels
        },
        metadata: {
          appName: "GridScaper",
          userAgent: navigator.userAgent,
          screenResolution: `${screen.width}x${screen.height}`
        }
      };

      // Convert to JSON string
      const jsonString = JSON.stringify(sceneData, null, 2);
      
      // Create download link
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      
      // Generate filename with timestamp
      const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      link.download = `gridscaper-scene-${timestamp}.json`;
      link.href = url;
      
      // Trigger download
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Clean up
      URL.revokeObjectURL(url);
      
      console.log('Scene exported successfully:', sceneData);
      
    } catch (error) {
      console.error('Error exporting scene:', error);
      alert('Error exporting scene. Please check the console for details.');
    }
  }

  function validateSceneData(data) {
    const errors = [];
    
    // Check required fields
    if (!data || typeof data !== 'object') {
      return ['Invalid JSON data structure'];
    }
    
    if (!data.version) {
      errors.push('Missing version field');
    }
    
    if (!Array.isArray(data.poles)) {
      errors.push('Missing or invalid poles array');
    } else {
      // Validate each pole
      data.poles.forEach((pole, index) => {
        if (typeof pole.x !== 'number' || typeof pole.z !== 'number' || 
            typeof pole.height !== 'number' || typeof pole.elevation !== 'number') {
          errors.push(`Invalid pole data at index ${index}`);
        }
        if (pole.height < 1 || pole.height > 100) {
          errors.push(`Pole height out of range at index ${index} (must be 1-100)`);
        }
      });
    }
    
    if (!data.settings || typeof data.settings !== 'object') {
      errors.push('Missing or invalid settings object');
    }
    
    // Validate terrain and surface data for v1.1+ (optional for backward compatibility)
    if (data.version !== "1.0" && data.terrain) {
      if (!data.terrain.dimensions || typeof data.terrain.dimensions.width !== 'number' || 
          typeof data.terrain.dimensions.depth !== 'number') {
        errors.push('Invalid terrain dimensions data');
      }
    }
    
    return errors;
  }

  function importScene(jsonData) {
    try {
      // Parse JSON if it's a string
      const sceneData = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
      
      // Validate scene data
      const validationErrors = validateSceneData(sceneData);
      if (validationErrors.length > 0) {
        throw new Error('Scene validation failed:\n' + validationErrors.join('\n'));
      }
      
      console.log('Importing scene:', sceneData);
      
      // Clear existing scene
      resetScene();
      
      // Restore terrain and surface data if available (v1.1+)
      if (sceneData.terrain && sceneData.surface && sceneData.version !== "1.0") {
        // Restore custom ground function if elevation profile exists
        if (sceneData.surface.hasCustomGround && sceneData.surface.elevationProfile) {
          const elevationProfile = sceneData.surface.elevationProfile;
          const bounds = sceneData.surface.bounds;
          
          customGround = (x, z) => {
            // Clamp z to the bounds of the elevation profile
            if (z <= bounds.minZ) return elevationProfile[0].elevation;
            if (z >= bounds.maxZ) return elevationProfile[elevationProfile.length - 1].elevation;
            
            // Find the segment and interpolate
            for (let i = 1; i < elevationProfile.length; i++) {
              if (z <= elevationProfile[i].z) {
                const t = (z - elevationProfile[i - 1].z) / (elevationProfile[i].z - elevationProfile[i - 1].z);
                return elevationProfile[i - 1].elevation * (1 - t) + elevationProfile[i].elevation * t;
              }
            }
            return elevationProfile[elevationProfile.length - 1].elevation;
          };
        } else {
          customGround = null;
        }
        
        console.log('Restored terrain data:', sceneData.terrain);
        console.log('Restored surface data:', sceneData.surface);
      }

      // Pre-populate poles array with imported data for terrain building
      const tempPoles = [];
      sceneData.poles.forEach(poleData => {
        tempPoles.push({ 
          x: poleData.x, 
          z: poleData.z, 
          h: poleData.height, 
          base: poleData.elevation
        });
      });
      
      // Rebuild terrain first with imported pole data to establish proper terrainOffsetZ
      if (tempPoles.length > 0) {
        showLoadingOverlay('Rebuilding terrain surface...');
        
        // Convert poles to the format expected by buildTerrain
        const customPolesForTerrain = tempPoles.map(pole => ({
          x: pole.x,
          z: pole.z,
          h: pole.h,
          elev: pole.base
        }));
        
        // Rebuild terrain with imported pole data
        const terrain = importedBuildTerrain(
          scene, 
          new URLSearchParams(), // Empty URL params since we have all the data
          customPolesForTerrain, 
          elements.terrainSelect, 
          elements.environmentSelect, 
          SEG, 
          hAt, 
          addGridLines, 
          addDefaultTrees, 
          null
        );
        
        fitGroundInView(camera, controls, terrain);
      }
      
      // Now import poles with correct terrainOffsetZ
      showLoadingOverlay('Importing poles...');
      sceneData.poles.forEach(poleData => {
        // Add pole with imported data
        const mesh = new THREE.Mesh(poleGeo, mPole);
        mesh.scale.y = poleData.height / BASE_H;
        mesh.position.set(poleData.x, poleData.elevation + poleData.height / 2, poleData.z + terrainOffsetZ);
        mesh.userData.pole = true;

        const crossArm = new THREE.Mesh(crossArmGeo, mCrossArm);
        crossArm.position.y = 5;
        mesh.add(crossArm);

        scene.add(mesh);
        poles.push({ 
          x: poleData.x, 
          z: poleData.z, 
          h: poleData.height, 
          base: poleData.elevation, 
          obj: mesh 
        });
      });
      
      // Import settings
      const settings = sceneData.settings;
      
      if (settings.tension !== undefined) {
        UIState.currentTension = settings.tension;
        if (elements.tensionSlider) {
          elements.tensionSlider.value = settings.tension;
          elements.tensionLabel.textContent = `${settings.tension} lbs`;
        }
      }
      
      if (settings.clearanceThreshold !== undefined) {
        UIState.clearanceThreshold = settings.clearanceThreshold;
        if (elements.clearanceThreshold) {
          elements.clearanceThreshold.value = settings.clearanceThreshold;
          elements.clearanceLabel.textContent = settings.clearanceThreshold;
        }
      }
      
      // Set dropdowns and checkboxes
      if (settings.terrain && elements.terrainSelect) {
        elements.terrainSelect.value = settings.terrain;
      }
      
      if (settings.environment && elements.environmentSelect) {
        elements.environmentSelect.value = settings.environment;
      }
      
      if (settings.setting && elements.settingSelect) {
        elements.settingSelect.value = settings.setting;
      }
      
      if (settings.showGrid !== undefined) {
        UIState.showGrid = settings.showGrid;
        if (elements.showGridCheck) {
          elements.showGridCheck.checked = settings.showGrid;
        }
      }
      
      if (settings.showSagCalculations !== undefined) {
        UIState.showSagCalculations = settings.showSagCalculations;
        if (elements.showSagCalculations) {
          elements.showSagCalculations.checked = settings.showSagCalculations;
        }
      }
      
      if (settings.showClearanceBuffers !== undefined) {
        UIState.showClearanceBuffers = settings.showClearanceBuffers;
        if (elements.showClearanceBuffers) {
          elements.showClearanceBuffers.checked = settings.showClearanceBuffers;
        }
      }
      
      if (settings.showPoleHeightLabels !== undefined) {
        UIState.showPoleHeightLabels = settings.showPoleHeightLabels;
        if (elements.showPoleHeightLabels) {
          elements.showPoleHeightLabels.checked = settings.showPoleHeightLabels;
        }
      }
      
      // Rebuild scene with imported data (spans and final positioning)
      showLoadingOverlay('Finalizing scene...');
      rebuild();
      updateCrossarmOrientations();
      updateLastPoleIndicator();
      toggleGridVisibility(UIState.showGrid);
      updateSagCalculations();
      updatePoleHeightLabels();
      checkClearances();
      
      // Success!
      setTimeout(() => {
        hideLoadingOverlay();
        alert(`Scene imported successfully!\n${sceneData.poles.length} poles loaded.`);
      }, 100); // Small delay to show "Rebuilding scene..." message
      
    } catch (error) {
      hideLoadingOverlay();
      console.error('Error importing scene:', error);
      alert(`Error importing scene:\n${error.message}`);
    }
  }

  // Loading overlay helpers
  function showLoadingOverlay(message = 'Loading scene...') {
    const overlay = document.getElementById('loadingOverlay');
    const text = overlay.querySelector('.loading-text');
    if (text) text.textContent = message;
    if (overlay) overlay.classList.add('active');
  }

  function hideLoadingOverlay() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) overlay.classList.remove('active');
  }

  function handleFileImport() {
    // Create file input
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    fileInput.multiple = false;
    
    fileInput.onchange = function(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Validate file size (max 10MB)
      if (file.size > 10 * 1024 * 1024) {
        alert('File size too large. Please select a file smaller than 10MB.');
        return;
      }
      
      // Validate file type
      if (!file.type.includes('json') && !file.name.toLowerCase().endsWith('.json')) {
        alert('Please select a valid JSON file.');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          showLoadingOverlay('Processing scene data...');
          
          // Use setTimeout to allow UI to update before heavy processing
          setTimeout(() => {
            try {
              showLoadingOverlay('Importing poles and terrain...');
              importScene(e.target.result);
              hideLoadingOverlay();
            } catch (error) {
              hideLoadingOverlay();
              console.error('File reading error:', error);
              alert('Error reading file. Please ensure it\'s a valid GridScaper scene file.');
            }
          }, 50);
        } catch (error) {
          hideLoadingOverlay();
          console.error('File reading error:', error);
          alert('Error reading file. Please ensure it\'s a valid GridScaper scene file.');
        }
      };
      
      reader.onerror = function() {
        hideLoadingOverlay();
        alert('Error reading file. Please try again.');
      };
      
      reader.readAsText(file);
    };
    
    // Trigger file picker
    fileInput.click();
  }

  // Add drag and drop functionality
  function setupDragAndDrop() {
    const overlay = document.getElementById('dragDropOverlay');
    let dragCounter = 0;

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // Highlight drop area when item is dragged over it
    ['dragenter', 'dragover'].forEach(eventName => {
      document.addEventListener(eventName, handleDragEnter, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      document.addEventListener(eventName, handleDragLeave, false);
    });

    function handleDragEnter(e) {
      dragCounter++;
      if (overlay) {
        overlay.classList.add('active');
      }
    }

    function handleDragLeave(e) {
      dragCounter--;
      if (dragCounter === 0 && overlay) {
        overlay.classList.remove('active');
      }
    }

    // Handle dropped files
    document.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
      dragCounter = 0;
      if (overlay) {
        overlay.classList.remove('active');
      }

      const dt = e.dataTransfer;
      const files = dt.files;

      if (files.length > 0) {
        const file = files[0];
        
        // Validate file type
        if (!file.type.includes('json') && !file.name.toLowerCase().endsWith('.json')) {
          alert('Please drop a valid JSON file.');
          return;
        }

        // Validate file size (max 10MB)
        if (file.size > 10 * 1024 * 1024) {
          alert('File size too large. Please select a file smaller than 10MB.');
          return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            showLoadingOverlay('Processing dropped file...');
            
            // Use setTimeout to allow UI to update before heavy processing
            setTimeout(() => {
              try {
                showLoadingOverlay('Importing poles and terrain...');
                importScene(e.target.result);
                hideLoadingOverlay();
              } catch (error) {
                hideLoadingOverlay();
                console.error('File reading error:', error);
                alert('Error reading file. Please ensure it\'s a valid GridScaper scene file.');
              }
            }, 50);
          } catch (error) {
            hideLoadingOverlay();
            console.error('File reading error:', error);
            alert('Error reading file. Please ensure it\'s a valid GridScaper scene file.');
          }
        };

        reader.onerror = function() {
          hideLoadingOverlay();
          alert('Error reading file. Please try again.');
        };

        reader.readAsText(file);
      }
    }
  }

  // Initialize drag and drop
  setupDragAndDrop();

  // Scenarios panel functionality
  const scenariosPanel = document.getElementById('scenariosPanel');
  const scenariosToggle = document.getElementById('scenariosToggle');
  const scenariosContent = document.getElementById('scenariosContent');
  
  if (scenariosToggle) {
    scenariosToggle.addEventListener('click', () => {
      const isCollapsed = scenariosContent.classList.contains('collapsed');
      if (isCollapsed) {
        scenariosContent.classList.remove('collapsed');
        scenariosToggle.textContent = '';
      } else {
        scenariosContent.classList.add('collapsed');
        scenariosToggle.textContent = '+';
      }
    });
  }
  
  // Handle scenario button clicks
  document.querySelectorAll('.scenario-button').forEach(button => {
    button.addEventListener('click', () => {
      const url = button.getAttribute('data-url');
      if (url) {
        window.location.href = url;
      }
    });
  });

  // HUD collapse/expand functionality
  const hudToggle = document.getElementById('hudToggle');
  const hudContent = document.getElementById('hudContent');
  const hudCollapseBtn = document.getElementById('hudCollapseBtn');
  
  if (hudToggle && hudContent && hudCollapseBtn) {
    hudToggle.addEventListener('click', () => {
      const isCollapsed = hudContent.classList.contains('collapsed');
      if (isCollapsed) {
        hudContent.classList.remove('collapsed');
        hudCollapseBtn.textContent = '';
      } else {
        hudContent.classList.add('collapsed');
        hudCollapseBtn.textContent = '+';
      }
    });
  }
});